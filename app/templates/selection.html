<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badge Image Selection</title>
    <link rel="stylesheet" href="{{ url_for('static', path='style.css') }}">
</head>
<body>
    <main class="container">
        {% if profile %}
            <header>
                <h1>{{ form.display_name or profile.name }}</h1>
                <p>
                    <button type="button" class="popover-link popover-link--inline" data-flash-link>
                        How do I update my badge?
                    </button>
                </p>
            </header>
            {% if sent %}
                <div class="alert success" role="status">
                    Badge saved successfully.
                </div>
            {% endif %}
            {% if error %}
                <div class="alert error" role="alert">
                    {{ error }}
                </div>
            {% endif %}
            <form method="post" class="selection-form" id="selection-form">
                <input type="hidden" name="image_label" id="selected-label" value="{{ form.image_label }}">
                <input type="hidden" name="text_x" id="text-x" value="{{ form.text_x }}">
                <input type="hidden" name="text_y" id="text-y" value="{{ form.text_y }}">
                <input type="hidden" name="download_after_save" id="download-after-save" value="0">
                {% set locked_images = profile.images
                    | selectattr('requires_secret_code')
                    | rejectattr('is_unlocked')
                    | list %}
                <div class="badge-editor{% if not form.image_label %} badge-editor--inactive{% endif %}" id="badge-editor">
                    <div class="badge-preview badge-preview--empty" id="badge-preview">
                        <img id="badge-preview-image" alt="" aria-hidden="true">
                        <div class="badge-preview__placeholder" id="badge-preview-placeholder">
                            Select an image to start customizing your badge.
                        </div>
                        <div class="badge-preview__guide" id="badge-preview-guide" aria-hidden="true"></div>
                        <canvas class="name-overlay" id="name-overlay-canvas" aria-hidden="true"></canvas>
                    </div>
                    <p class="badge-instruction">Drag your name around on the preview, then adjust the slider to resize it.</p>
                </div>
                <div class="customization-controls customization-controls--two-column">
                    <label class="field control-card">
                        <span>Name</span>
                        <input
                            type="text"
                            name="override_name"
                            id="badge-name-input"
                            value="{{ form.display_name or profile.name }}"
                            maxlength="{{ MAX_BADGE_NAME_LENGTH }}"
                            pattern="[A-Za-z0-9 :.,!?'&quot;_-]+"
                            title="Use letters, numbers, spaces, and : . , ! ? \" ' - _"
                        >
                    </label>
                    <label class="field control-card">
                        <span>Font Size</span>
                        <div class="font-size-control">
                            <input
                                type="range"
                                name="font_size"
                                id="font-size-input"
                                min="{{ MIN_BADGE_FONT_SIZE }}"
                                max="{{ MAX_BADGE_FONT_SIZE }}"
                                value="{{ form.font_size }}"
                                step="1"
                                disabled
                            >
                            <span class="font-size-output" id="font-size-output">{{ form.font_size }}</span>
                            <span class="font-size-unit">px</span>
                        </div>
                    </label>
                    <label class="field control-card">
                        <span>Tilt</span>
                        <div class="font-size-control">
                            <input
                                type="range"
                                name="text_rotation"
                                id="rotation-input"
                                min="{{ MIN_BADGE_TEXT_ROTATION }}"
                                max="{{ MAX_BADGE_TEXT_ROTATION }}"
                                value="{{ form.text_rotation }}"
                                step="1"
                                disabled
                            >
                            <span class="font-size-output" id="rotation-output">{{ form.text_rotation }}</span>
                            <span class="font-size-unit">deg</span>
                        </div>
                    </label>
                </div>
                <div class="gallery gallery--selection">
                    {% for image in profile.images %}
                        {% set is_locked = image.requires_secret_code and not image.is_unlocked %}
                        <button
                            type="button"
                            class="thumbnail{% if form.image_label == image.label %} active{% endif %}{% if is_locked %} thumbnail--locked{% endif %}"
                            data-label="{{ image.label }}"
                            data-color="{{ image.image_color or 'black' }}"
                            data-font="{{ image.image_font or 'Awkward.ttf' }}"
                            data-locked="{{ 'true' if is_locked else 'false' }}"
                            data-src="data:{{ image.image_mime_type or 'image/png' }};base64,{{ image.image_base64 }}"
                        >
                            <div class="thumbnail__media">
                                <img
                                    data-thumbnail-image
                                    alt="{{ image.label }}"
                                    src="data:{{ image.image_mime_type or 'image/png' }};base64,{{ image.image_base64 }}"
                                >
                                {% if is_locked %}
                                    <div class="thumbnail__lock-overlay" data-lock-overlay>
                                        <span aria-hidden="true">Locked</span>
                                        <small>Enter the code to reveal</small>
                                    </div>
                                {% endif %}
                            </div>
                            <span>{{ image.label }}</span>
                        </button>
                    {% else %}
                        <p class="empty-state">No images available for this badge.</p>
                    {% endfor %}
                </div>
                {% if locked_images %}
                    <section class="unlock-panel" id="unlock-panel">
                        <p>Enter the secret code to reveal a locked images.</p>
                        <div class="unlock-form" id="unlock-form">
                            <label class="field">
                                <input
                                    type="text"
                                    id="unlock-secret-code"
                                    maxlength="{{ MAX_IMAGE_SECRET_CODE_LENGTH }}"
                                    autocomplete="off"
                                >
                            </label>
                            <button type="button" class="secondary unlock-form__button" id="unlock-image-button">
                                Unlock
                            </button>
                            <p class="unlock-message" id="unlock-message" aria-live="polite"></p>
                        </div>
                    </section>
                {% endif %}
                <div class="action-buttons">
                    <button type="submit" class="primary" id="send-button" {% if not form.image_label %}disabled{% endif %}>
                        Save
                    </button>
                    {% if profile.firmware_base64 %}
                        <a
                            class="secondary download-button"
                            id="download-firmware-link"
                            href="data:application/octet-stream;base64,{{ profile.firmware_base64 }}"
                            download="{{ profile.unique_id }}.bin"
                        >
                            Download Firmware
                        </a>
                    {% else %}
                        <button type="button" class="secondary download-button" disabled>
                            Download Firmware
                        </button>
                    {% endif %}
                </div>
            </form>
        {% else %}
            <header>
                <h1>Badge Lookup</h1>
            </header>
            <div class="alert error" role="alert">
                {{ error or "We couldn't find that badge. Please verify the link." }}
            </div>
        {% endif %}
    </main>
    <a class="pi-easter-egg" href="{{ url_for('pizza_easter_egg') }}" aria-label="π">
        π
    </a>
    <div class="popover-panel" id="flash-instructions-panel" role="dialog" aria-modal="true" aria-labelledby="flash-instructions-title">
        <div class="popover-content">
            <h3 id="flash-instructions-title">Flash Your Badge</h3>
            <ol>
                <li>Select an image and customize your name.</li>
                <li>Click "Save" to store settings.</li>
                <li>Plug your badge into the programmer at registration.</li>
                <li>Your badge should update with your image.</li>
                <li>If you encounter issues, ask a staff member for assistance.</li>
            </ol>
            <p class="popover-hint">Hint: Keep an eye out for secret codes around the con to unlock even more images.</p
            <button type="button" class="popover-close" id="flash-instructions-close">Close</button>
        </div>
    </div>
    <script>
        (function () {
            const defaultName = {{ (profile.name if profile else '') | tojson }};
            let attendeeName = {{ ((form.display_name or profile.name) if profile else '') | tojson }};
            const badgeEditor = document.getElementById('badge-editor');
            if (!badgeEditor) {
                return;
            }
            if (!attendeeName) {
                attendeeName = defaultName;
                if (!attendeeName) {
                    return;
                }
            }

            const buttons = Array.from(document.querySelectorAll('.thumbnail'));
            const buttonMap = new Map(buttons.map(button => [button.dataset.label, button]));
            const selectionInput = document.getElementById('selected-label');
            const textXInput = document.getElementById('text-x');
            const textYInput = document.getElementById('text-y');
            const fontSizeInput = document.getElementById('font-size-input');
            const fontSizeOutput = document.getElementById('font-size-output');
            const rotationInput = document.getElementById('rotation-input');
            const rotationOutput = document.getElementById('rotation-output');
            const sendButton = document.getElementById('send-button');
            const downloadLink = document.getElementById('download-firmware-link');
            const downloadAfterSaveInput = document.getElementById('download-after-save');
            const flashInstructionLinks = document.querySelectorAll('[data-flash-link]');
            const previewContainer = document.getElementById('badge-preview');
            const previewImage = document.getElementById('badge-preview-image');
            const previewPlaceholder = document.getElementById('badge-preview-placeholder');
            const previewGuide = document.getElementById('badge-preview-guide');
            const overlayCanvas = document.getElementById('name-overlay-canvas');
            const overlayCtx = overlayCanvas.getContext('2d');
            const nameInput = document.getElementById('badge-name-input');
            const unlockPanel = document.getElementById('unlock-panel');
            const unlockCodeInput = document.getElementById('unlock-secret-code');
            const unlockButton = document.getElementById('unlock-image-button');
            const unlockMessage = document.getElementById('unlock-message');
            const unlockEndpoint = `${window.location.pathname.replace(/\/$/, '')}/unlock`;
            const selectionForm = document.getElementById('selection-form');
            const instructionsPanel = document.getElementById('flash-instructions-panel');
            const instructionCloseButton = document.getElementById('flash-instructions-close');

            const PREVIEW_VISIBLE_CLASS = 'badge-preview__image--visible';
            const PREVIEW_MAX_WIDTH = 960;
            const PREVIEW_SCALE = 4;
            const FONT_BASE_PATH = "{{ url_for('static', path='fonts/') }}";
            const DEFAULT_ROTATION = {{ DEFAULT_BADGE_TEXT_ROTATION | tojson }};
            const fontCache = new Map();

            let autoDownloadPending = {{ "true" if auto_download else "false" }};
            let skipSaveForDownload = false;

            let activeButton = null;
            let currentScale = 1;
            let dragPointerId = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let pendingReset = false;
            let pendingColor = 'black';
            let currentFontFamily = '';
            let currentFontColor = '#000';
            let currentRotation = rotationInput ? parseInt(rotationInput.value, 10) || DEFAULT_ROTATION : DEFAULT_ROTATION;

            function updateFontSizeDisplay() {
                fontSizeOutput.textContent = fontSizeInput.value;
            }

            function updateRotationDisplay() {
                if (rotationInput && rotationOutput) {
                    rotationOutput.textContent = rotationInput.value;
                }
            }

            if (downloadAfterSaveInput) {
                downloadAfterSaveInput.value = '0';
            }

            if (downloadLink && selectionForm && downloadAfterSaveInput) {
                downloadLink.addEventListener('click', event => {
                    if (skipSaveForDownload) {
                        skipSaveForDownload = false;
                        return;
                    }
                    event.preventDefault();
                    downloadAfterSaveInput.value = '1';
                    selectionForm.requestSubmit();
                });
            }

            function clearOverlayCanvas() {
                overlayCanvas.width = 0;
                overlayCanvas.height = 0;
                overlayCanvas.style.width = '0px';
                overlayCanvas.style.height = '0px';
            }

            function hidePlaceholder() {
                previewPlaceholder.hidden = true;
                previewPlaceholder.classList.add('is-hidden');
                previewContainer.classList.remove('badge-preview--empty');
                if (previewGuide) {
                    previewGuide.style.display = 'none';
                    previewGuide.style.removeProperty('top');
                    previewGuide.style.removeProperty('left');
                    previewGuide.style.removeProperty('width');
                    previewGuide.style.removeProperty('height');
                }
            }

            function showPlaceholder() {
                previewPlaceholder.hidden = false;
                previewPlaceholder.classList.remove('is-hidden');
                previewImage.classList.remove(PREVIEW_VISIBLE_CLASS);
                previewContainer.classList.add('badge-preview--empty');
                previewContainer.style.removeProperty('width');
                previewContainer.style.removeProperty('height');
                previewImage.style.removeProperty('width');
                previewImage.style.removeProperty('height');
                if (previewGuide) {
                    previewGuide.style.display = 'none';
                    previewGuide.style.removeProperty('top');
                    previewGuide.style.removeProperty('left');
                    previewGuide.style.removeProperty('width');
                    previewGuide.style.removeProperty('height');
                }
                overlayCanvas.style.display = 'none';
                clearOverlayCanvas();
            }

            function setEditorEnabled(enabled) {
                badgeEditor.classList.toggle('badge-editor--inactive', !enabled);
                fontSizeInput.disabled = !enabled;
                if (rotationInput) {
                    rotationInput.disabled = !enabled;
                }
                overlayCanvas.style.pointerEvents = enabled ? 'auto' : 'none';
                if (!enabled && !selectionInput.value) {
                    showPlaceholder();
                }
            }

            function setUnlockStatus(message, isError = false) {
                if (!unlockMessage) {
                    return;
                }
                unlockMessage.textContent = message || '';
                unlockMessage.classList.toggle('unlock-message--error', Boolean(isError && message));
            }

            function focusUnlockPanel(label) {
                if (!unlockPanel) {
                    return;
                }
                unlockPanel.scrollIntoView({ behavior: 'smooth', block: 'center' });
                if (unlockCodeInput) {
                    window.requestAnimationFrame(() => unlockCodeInput.focus());
                }
            }

            function updateLockPanelVisibility() {
                if (!unlockPanel) {
                    return;
                }
                const remainingLocked = buttons.some(btn => btn.dataset.locked === 'true');
                unlockPanel.style.display = remainingLocked ? '' : 'none';
                if (!remainingLocked) {
                    setUnlockStatus('');
                }
            }

            function applyUnlockedImage(payload, shouldActivate = true) {
                if (!payload || !payload.image_label) {
                    return;
                }
                const label = payload.image_label;
                const button = buttonMap.get(label);
                if (!button) {
                    return;
                }
                const imageMime = payload.image_mime_type || 'image/png';
                const dataUri = `data:${imageMime};base64,${payload.image_base64}`;
                button.dataset.locked = 'false';
                button.dataset.src = dataUri;
                button.dataset.color = payload.image_color || 'black';
                button.dataset.font = payload.image_font || '';
                button.classList.remove('thumbnail--locked');
                const imgEl = button.querySelector('[data-thumbnail-image]');
                if (imgEl) {
                    imgEl.src = dataUri;
                }
                const overlay = button.querySelector('[data-lock-overlay]');
                if (overlay) {
                    overlay.remove();
                }
                updateLockPanelVisibility();
                if (shouldActivate) {
                    setActiveButton(button, true).catch(error => console.error(error));
                }
            }

            async function attemptUnlock() {
                if (!unlockCodeInput) {
                    return;
                }
                const code = unlockCodeInput.value.trim();
                if (!code) {
                    setUnlockStatus('Enter the secret code.', true);
                    unlockCodeInput.focus();
                    return;
                }
                if (unlockButton) {
                    unlockButton.disabled = true;
                }
                setUnlockStatus('Checking code...');
                try {
                    const response = await fetch(unlockEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            secret_code: code,
                        }),
                    });
                    if (!response.ok) {
                        let errorMessage = 'Invalid secret code.';
                        try {
                            const errorPayload = await response.json();
                            if (errorPayload && errorPayload.detail) {
                                errorMessage = errorPayload.detail;
                            }
                        } catch (_) {
                            // Ignore parse failures.
                        }
                        throw new Error(errorMessage);
                    }
                    const payload = await response.json();
                    applyUnlockedImage(payload);
                    unlockCodeInput.value = '';
                    setUnlockStatus(`Unlocked ${payload.image_label}.`);
                } catch (error) {
                    console.error(error);
                    setUnlockStatus(error.message || 'Could not unlock that image.', true);
                } finally {
                    if (unlockButton) {
                        unlockButton.disabled = false;
                    }
                }
            }

            function sanitizeFontFamily(fontFilename) {
                return `badge-font-${fontFilename.replace(/[^a-zA-Z0-9]+/g, '-')}`;
            }

            async function ensureOverlayFont(fontFilename) {
                if (!fontFilename) {
                    currentFontFamily = '';
                    return '';
                }
                if (fontCache.has(fontFilename)) {
                    currentFontFamily = fontCache.get(fontFilename);
                    return currentFontFamily;
                }

                const fontFamily = sanitizeFontFamily(fontFilename);
                const fontUrl = `${FONT_BASE_PATH}${fontFilename}`;

                try {
                    const fontFace = new FontFace(fontFamily, `url('${fontUrl}')`);
                    const loadedFace = await fontFace.load();
                    document.fonts.add(loadedFace);
                    fontCache.set(fontFilename, fontFamily);
                    currentFontFamily = fontFamily;
                    return fontFamily;
                } catch (error) {
                    console.error('Failed to load font', fontFilename, error);
                    currentFontFamily = '';
                    return '';
                }
            }

            function redrawOverlay() {
                if (!selectionInput.value) {
                    overlayCanvas.style.display = 'none';
                    clearOverlayCanvas();
                    return;
                }

                const fontSize = parseInt(fontSizeInput.value, 10);
                if (!Number.isFinite(fontSize) || currentScale <= 0) {
                    return;
                }

                const displayFontSize = fontSize * currentScale;
                const fontFamily = currentFontFamily || window.getComputedStyle(document.body).fontFamily || 'sans-serif';
                const dpr = window.devicePixelRatio || 1;

                overlayCanvas.style.display = 'block';

                overlayCtx.font = `${displayFontSize}px ${fontFamily}`;
                const metrics = overlayCtx.measureText(attendeeName);
                const width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                const height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                const leftBearing = metrics.actualBoundingBoxLeft;
                const ascent = metrics.actualBoundingBoxAscent;

                const baseWidth = Math.max(1, Math.ceil(width));
                const baseHeight = Math.max(1, Math.ceil(height));
                const rotationRadians = (currentRotation * Math.PI) / 180;
                const absCos = Math.abs(Math.cos(rotationRadians));
                const absSin = Math.abs(Math.sin(rotationRadians));
                const rotatedWidth = Math.max(1, Math.ceil(baseWidth * absCos + baseHeight * absSin));
                const rotatedHeight = Math.max(1, Math.ceil(baseWidth * absSin + baseHeight * absCos));

                overlayCanvas.width = Math.max(1, Math.ceil(rotatedWidth * dpr));
                overlayCanvas.height = Math.max(1, Math.ceil(rotatedHeight * dpr));
                overlayCanvas.style.width = `${rotatedWidth}px`;
                overlayCanvas.style.height = `${rotatedHeight}px`;

                overlayCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                overlayCtx.clearRect(0, 0, rotatedWidth, rotatedHeight);
                overlayCtx.translate(rotatedWidth / 2, rotatedHeight / 2);
                overlayCtx.rotate(rotationRadians);
                overlayCtx.translate(-baseWidth / 2, -baseHeight / 2);
                overlayCtx.font = `${displayFontSize}px ${fontFamily}`;
                overlayCtx.textBaseline = 'alphabetic';
                overlayCtx.fillStyle = currentFontColor;
                overlayCtx.fillText(attendeeName, leftBearing, ascent);
                overlayCtx.setTransform(1, 0, 0, 1, 0, 0);
            }

            function updateOverlayColors(color) {
                currentFontColor = color === 'black' ? '#1a1a1a' : '#e6e6e6';
                redrawOverlay();
            }

            function getContainerSize() {
                return {
                    width: previewContainer.clientWidth,
                    height: previewContainer.clientHeight,
                };
            }

            function updateScale() {
                if (!previewImage.naturalWidth || !previewImage.naturalHeight) {
                    currentScale = 1;
                    if (previewGuide) {
                        previewGuide.style.display = 'none';
                        previewGuide.style.removeProperty('top');
                        previewGuide.style.removeProperty('left');
                        previewGuide.style.removeProperty('width');
                        previewGuide.style.removeProperty('height');
                    }
                    return;
                }

                const parentWidth = badgeEditor.clientWidth || previewImage.naturalWidth;
                const scaledWidth = previewImage.naturalWidth * PREVIEW_SCALE;
                const targetWidth = Math.min(PREVIEW_MAX_WIDTH, parentWidth, scaledWidth);
                const scale = targetWidth / previewImage.naturalWidth;
                const displayWidth = Math.round(previewImage.naturalWidth * scale);
                const displayHeight = Math.round(previewImage.naturalHeight * scale);

                previewContainer.style.width = `${displayWidth}px`;
                previewContainer.style.height = `${displayHeight}px`;
                previewImage.style.width = `${displayWidth}px`;
                previewImage.style.height = `${displayHeight}px`;

                currentScale = scale;
                redrawOverlay();
                applyOverlayPosition();
                updateGuideHeight();
            }

            function updateGuideHeight() {
                if (!previewGuide || !selectionInput.value || currentScale <= 0) {
                    if (previewGuide) {
                        previewGuide.style.display = 'none';
                        previewGuide.style.removeProperty('top');
                        previewGuide.style.removeProperty('left');
                        previewGuide.style.removeProperty('width');
                        previewGuide.style.removeProperty('height');
                    }
                    return;
                }

                const rawInset = 2;
                const rawHeight = 28;
                const inset = rawInset * currentScale;
                const containerWidth = previewContainer.clientWidth || (previewImage.naturalWidth * currentScale);
                const containerHeight = previewContainer.clientHeight || (previewImage.naturalHeight * currentScale);
                const guideWidth = Math.max(containerWidth - inset * 2, 0);
                const clampedHeight = Math.min(containerHeight - inset * 2, rawHeight * currentScale);

                previewGuide.style.top = `${inset}px`;
                previewGuide.style.left = `${inset}px`;
                previewGuide.style.width = `${guideWidth}px`;
                previewGuide.style.height = `${Math.max(clampedHeight, 0)}px`;
                previewGuide.style.display = 'block';
            }

            function updateHiddenFromDisplay(displayX, displayY) {
                if (currentScale <= 0) {
                    return;
                }
                const rawX = displayX / currentScale;
                const rawY = displayY / currentScale;
                textXInput.value = Math.max(0, Math.floor(rawX));
                textYInput.value = Math.max(0, Math.floor(rawY));
            }

            function setOverlayPosition(displayX, displayY) {
                const { width, height } = getContainerSize();
                const overlayWidth = overlayCanvas.offsetWidth;
                const overlayHeight = overlayCanvas.offsetHeight;
                const maxX = Math.max(width - overlayWidth, 0);
                const maxY = Math.max(height - overlayHeight, 0);
                const clampedX = Math.min(Math.max(displayX, 0), maxX);
                const clampedY = Math.min(Math.max(displayY, 0), maxY);
                overlayCanvas.style.left = `${clampedX}px`;
                overlayCanvas.style.top = `${clampedY}px`;
                updateHiddenFromDisplay(clampedX, clampedY);
            }

            function applyOverlayPosition() {
                if (!selectionInput.value) {
                    return;
                }
                const xValue = parseInt(textXInput.value, 10);
                const yValue = parseInt(textYInput.value, 10);
                if (Number.isFinite(xValue) && Number.isFinite(yValue)) {
                    setOverlayPosition(xValue * currentScale, yValue * currentScale);
                } else {
                    centerOverlay();
                }
            }

            function centerOverlay() {
                const { width, height } = getContainerSize();
                const overlayWidth = overlayCanvas.offsetWidth;
                const overlayHeight = overlayCanvas.offsetHeight;
                const centerX = Math.max((width - overlayWidth) / 2, 0);
                const centerY = Math.max((height - overlayHeight) / 2, 0);
                setOverlayPosition(centerX, centerY);
            }

            function applyFontSize() {
                const fontSize = parseInt(fontSizeInput.value, 10);
                if (!Number.isFinite(fontSize)) {
                    return;
                }
                updateFontSizeDisplay();
                redrawOverlay();
                applyOverlayPosition();
            }

            function onPreviewLoaded() {
                if (!selectionInput.value) {
                    return;
                }
                hidePlaceholder();
                setEditorEnabled(true);
                updateScale();
                if (pendingReset) {
                    textXInput.value = '';
                    textYInput.value = '';
                }
                applyFontSize();
                updateOverlayColors(pendingColor);
                previewImage.classList.add(PREVIEW_VISIBLE_CLASS);
                updateGuideHeight();
                pendingReset = false;
            }

            previewImage.addEventListener('load', onPreviewLoaded);

            window.addEventListener('resize', () => {
                if (!selectionInput.value || !previewImage.naturalWidth) {
                    return;
                }
                updateScale();
            });

            fontSizeInput.addEventListener('input', () => {
                if (fontSizeInput.disabled) {
                    return;
                }
                applyFontSize();
            });

            if (rotationInput) {
                rotationInput.addEventListener('input', () => {
                    if (rotationInput.disabled) {
                        return;
                    }
                    const parsed = parseInt(rotationInput.value, 10);
                    currentRotation = Number.isFinite(parsed) ? parsed : DEFAULT_ROTATION;
                    updateRotationDisplay();
                    redrawOverlay();
                    applyOverlayPosition();
                });
            }

            async function setActiveButton(button, shouldResetPosition) {
                if (!button || button.dataset.locked === 'true') {
                    if (button) {
                        focusUnlockPanel(button.dataset.label);
                    }
                    return;
                }
                buttons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                activeButton = button;
                selectionInput.value = button.dataset.label;
                sendButton.disabled = false;
                pendingColor = button.dataset.color || 'white';
                pendingReset = shouldResetPosition;
                if (shouldResetPosition) {
                    textXInput.value = '';
                    textYInput.value = '';
                    if (rotationInput) {
                        rotationInput.value = String(DEFAULT_ROTATION);
                        currentRotation = DEFAULT_ROTATION;
                        updateRotationDisplay();
                    }
                }
                setEditorEnabled(false);
                hidePlaceholder();
                overlayCanvas.style.display = 'none';
                clearOverlayCanvas();
                if (previewGuide) {
                    previewGuide.style.display = 'none';
                    previewGuide.style.removeProperty('top');
                    previewGuide.style.removeProperty('left');
                    previewGuide.style.removeProperty('width');
                    previewGuide.style.removeProperty('height');
                }

                if (button.dataset.font) {
                    await ensureOverlayFont(button.dataset.font);
                } else {
                    currentFontFamily = '';
                }

                updateOverlayColors(pendingColor);

                if (button.dataset.src) {
                    const targetSrc = button.dataset.src;
                    if (previewImage.src === targetSrc) {
                        window.requestAnimationFrame(onPreviewLoaded);
                    } else {
                        previewImage.src = targetSrc;
                    }
                }
            }

            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    if (button.dataset.locked === 'true') {
                        focusUnlockPanel(button.dataset.label);
                        return;
                    }
                    setActiveButton(button, true).catch(error => console.error(error));
                });
            });

            function beginDrag(event) {
                if (badgeEditor.classList.contains('badge-editor--inactive') || overlayCanvas.style.display !== 'block') {
                    return;
                }
                dragPointerId = event.pointerId;
                const overlayRect = overlayCanvas.getBoundingClientRect();
                dragOffsetX = event.clientX - overlayRect.left;
                dragOffsetY = event.clientY - overlayRect.top;
                overlayCanvas.setPointerCapture(dragPointerId);
                overlayCanvas.classList.add('name-overlay--dragging');
                event.preventDefault();
            }

            function drag(event) {
                if (event.pointerId !== dragPointerId) {
                    return;
                }
                const containerRect = previewContainer.getBoundingClientRect();
                const newLeft = event.clientX - containerRect.left - dragOffsetX;
                const newTop = event.clientY - containerRect.top - dragOffsetY;
                setOverlayPosition(newLeft, newTop);
            }

            function endDrag(event) {
                if (event.pointerId !== dragPointerId) {
                    return;
                }
                overlayCanvas.releasePointerCapture(dragPointerId);
                dragPointerId = null;
                overlayCanvas.classList.remove('name-overlay--dragging');
            }

            overlayCanvas.addEventListener('pointerdown', beginDrag);
            overlayCanvas.addEventListener('pointermove', drag);
            overlayCanvas.addEventListener('pointerup', endDrag);
            overlayCanvas.addEventListener('pointercancel', endDrag);

            if (unlockButton) {
                unlockButton.addEventListener('click', () => {
                    attemptUnlock().catch(error => console.error(error));
                });
            }
            if (unlockCodeInput) {
                unlockCodeInput.addEventListener('keydown', event => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        attemptUnlock().catch(error => console.error(error));
                    }
                });
            }

            updateFontSizeDisplay();
            updateRotationDisplay();
            updateLockPanelVisibility();

            if (selectionInput.value) {
                const initialButton = buttons.find(btn => btn.dataset.label === selectionInput.value);
                if (initialButton) {
                    if (initialButton.dataset.locked === 'true') {
                        focusUnlockPanel(initialButton.dataset.label);
                    } else {
                        setActiveButton(initialButton, false).catch(error => console.error(error));
                    }
                }
            } else {
                showPlaceholder();
                setEditorEnabled(false);
            }

            if (nameInput) {
                nameInput.addEventListener('input', () => {
                    attendeeName = nameInput.value.trim() || defaultName;
                    redrawOverlay();
                    applyOverlayPosition();
                });
            }

            if (autoDownloadPending && downloadLink) {
                setTimeout(() => {
                    skipSaveForDownload = true;
                    downloadLink.click();
                }, 400);
            }

            function toggleInstructions(show) {
                if (!instructionsPanel) {
                    return;
                }
                instructionsPanel.classList.toggle('is-visible', show);
            }

            if (flashInstructionLinks.length && instructionsPanel) {
                flashInstructionLinks.forEach(link =>
                    link.addEventListener('click', () => toggleInstructions(true))
                );
            }
            if (instructionCloseButton) {
                instructionCloseButton.addEventListener('click', () => toggleInstructions(false));
            }
            if (instructionsPanel) {
                instructionsPanel.addEventListener('click', event => {
                    if (event.target === instructionsPanel) {
                        toggleInstructions(false);
                    }
                });
            }
        })();
    </script>
</body>
</html>
